### 2023/03/09

이벤트 발생 -> 상태 변경 -> 렌더링 흐름으로 컴포넌트를 구성하려고 했음.
간단하게 counter app을 만들어서 테스트를 했음.
상태 변경 후에 리렌더링을 할 때 렌더링 함수 안에 `innerHTML`을 사용하고 있어 이벤트를 다시 등록해줘야함.

### 2023/03/11

하위 컴포넌트에 전달하는 이벤트 props의 로직은 `this.setState()`가 포함된 경우가 많은데 해당 함수가 하위 컴포넌트에 호출될 때 this의 값이 하위 컴포넌트로 결정되어 `setState()`를 실행할 수 없음.
그래서 전달할 때 `bind`로 this의 값을 상위 컴포넌트로 설정하였음.

- `bind`를 사용했을 때의 단점
  `bind`를 사용하면 복잡성이 증가하게됨. => 어떤 곳에서는 `bind`를 하지 않고, 어느 곳에서는 한다면 유지보수가 힘들어짐.
  일반 함수 호출보다 많은 성능이 필요하고 추가적인 메모리가 필요함.

### 2023/03/12

첫 번째 리팩토링 진행. 이번 리팩토링의 목표는 컴포넌트 별 일관성을 유지시킬 수 있도록 하고, 하위 컴포넌트에 함수를 전달할 때 `bind`를 제거하여 전달하는 방법찾기

### 2023/03/13

신경써야될 부분들

- **DOM접근 최소화**

  - 브라우저가 DOM에 접근하고 DOM을 수정하는 일은 CPU를 많이 사용하기 때문에 성능 저하의 원인이 됨.
  - 따라서 리스트를 하나씩 추가하거나 수정하는 것보다 Fragment를 사용해서 한 번에 업데이트를 하거나 이벤트 위임으로 여러 요소에 이벤트를 등록하는 것보다 상위 요소에 이벤트 리스너를 등록하도록 한다.

- **컴포넌트 일관성**
  - 컴포넌트 내부 로직이나 흐름을 일관성있게 하기. 컴포넌트가 추가되거나 복잡해지면서 코드 파악이 힘들 수 있음.
